#include "vhci.h"

#include <wdmsec.h> // for IoCreateDeviceSecure

#include "device.h"
#include "usbip_vhci_api.h"

//
// This guid is used in IoCreateDeviceSecure call to create PDOs. The idea is to
// allow the administrators to control access to the child device, in case the
// device gets enumerated as a raw device - no function driver, by modifying the 
// registry. If a function driver is loaded for the device, the system will override
// the security descriptor specified in the call to IoCreateDeviceSecure with the 
// one specifyied for the setup class of the child device.
//
DEFINE_GUID(GUID_SD_USBIP_VHCI_PDO,
	0x9d3039dd, 0xcca5, 0x4b4d, 0xb3, 0x3d, 0xe2, 0xdd, 0xc8, 0xa8, 0xc5, 0x2e);
// {9D3039DD-CCA5-4b4d-B33D-E2DDC8A8C52E}

extern PAGEABLE void
bus_init_pdo(PDEVICE_OBJECT pdo, PFDO_DEVICE_DATA fdodata);

PAGEABLE NTSTATUS
bus_plugin_dev(ioctl_usbip_vhci_plugin *plugin, PFDO_DEVICE_DATA fdodata, PFILE_OBJECT fo)
{
	PDEVICE_OBJECT      pdo;
	PPDO_DEVICE_DATA    pdodata, old_pdodata;
	NTSTATUS            status;
	ULONG               len;
	PLIST_ENTRY         entry;
	unsigned long i;

	PAGED_CODE();

	DBGI(DBG_PNP, "Exposing PDO: addr: %d, vendor:product: %04x:%04x\n", plugin->addr, plugin->vendor, plugin->product);

	if (plugin->addr <= 0)
		return STATUS_INVALID_PARAMETER;

	ExAcquireFastMutex(&fdodata->Mutex);

	for (entry = fdodata->ListOfPDOs.Flink; entry != &fdodata->ListOfPDOs; entry = entry->Flink) {
		pdodata = CONTAINING_RECORD(entry, PDO_DEVICE_DATA, Link);
		if ((ULONG)plugin->addr == pdodata->SerialNo &&
			pdodata->common.DevicePnPState != SurpriseRemovePending) {
			ExReleaseFastMutex(&fdodata->Mutex);
			return STATUS_INVALID_PARAMETER;
		}
	}

	ExReleaseFastMutex(&fdodata->Mutex);

	// Create the PDO
	//
	DBGI(DBG_PNP, "fdodata->NextLowerDriver = 0x%p\n", fdodata->NextLowerDriver);

	//
	// PDO must have a name. You should let the system auto generate a
	// name by specifying FILE_AUTOGENERATED_DEVICE_NAME in the
	// DeviceCharacteristics parameter. Let us create a secure deviceobject,
	// in case the child gets installed as a raw device (RawDeviceOK), to prevent
	// an unpriviledged user accessing our device. This function is avaliable
	// in a static WDMSEC.LIB and can be used in Win2k, XP, and Server 2003
	// Just make sure that  the GUID specified here is not a setup class GUID.
	// If you specify a setup class guid, you must make sure that class is
	// installed before enumerating the PDO.
	//

	status = IoCreateDeviceSecure(fdodata->common.Self->DriverObject,
		sizeof(PDO_DEVICE_DATA),
		NULL,
		FILE_DEVICE_BUS_EXTENDER,
		FILE_AUTOGENERATED_DEVICE_NAME | FILE_DEVICE_SECURE_OPEN,
		FALSE,
		&SDDL_DEVOBJ_SYS_ALL_ADM_RWX_WORLD_RWX_RES_RWX, // allow normal users to access the devices
		(LPCGUID)&GUID_SD_USBIP_VHCI_PDO,
		&pdo);
	if (!NT_SUCCESS(status)) {
		return status;
	}

	pdodata = (PPDO_DEVICE_DATA)pdo->DeviceExtension;

#define HARDWARE_IDS_TPL L"USB\\Vid_%04x&Pid_%04x&Rev_%04xZUSB\\Vid_%04x&Pid_%04xZ"

	len = sizeof(HARDWARE_IDS_TPL);
	pdodata->HardwareIDs = ExAllocatePoolWithTag(NonPagedPool, len, USBIP_VHCI_POOL_TAG);
	if (NULL == pdodata->HardwareIDs) {
		IoDeleteDevice(pdo);
		return STATUS_INSUFFICIENT_RESOURCES;
	}
	RtlStringCchPrintfW(pdodata->HardwareIDs, len / sizeof(wchar_t), HARDWARE_IDS_TPL,
		plugin->vendor, plugin->product, plugin->version, plugin->vendor, plugin->product);
	for (i = 0; i<len / sizeof(wchar_t); i++) {
		if ('Z' == pdodata->HardwareIDs[i])
			pdodata->HardwareIDs[i] = 0;
	}
#define COMPATIBLE_IDS_TPL L"USB\\Class_%02x&SubClass_%02x&Prot_%02xZUSB\\Class_%02x&SubClass_%02xZUSB\\Class_%02xZ"
#define COMPATIBLE_COMPOSITE_IDS_TPL L"USB\\Class_%02x&SubClass_%02x&Prot_%02xZUSB\\Class_%02x&SubClass_%02xZUSB\\Class_%02xZUSB\\COMPOSITEZ"
	if (plugin->inum>1)
		len = sizeof(COMPATIBLE_COMPOSITE_IDS_TPL);
	else
		len = sizeof(COMPATIBLE_IDS_TPL);
	pdodata->compatible_ids = ExAllocatePoolWithTag(NonPagedPool, len, USBIP_VHCI_POOL_TAG);

	if (NULL == pdodata->compatible_ids) {
		ExFreePool(pdodata->HardwareIDs);
		IoDeleteDevice(pdo);
		return STATUS_INSUFFICIENT_RESOURCES;
	}
	RtlZeroMemory(pdodata->compatible_ids, len);

	pdodata->compatible_ids_len = len;
	RtlStringCchPrintfW(pdodata->compatible_ids, len / sizeof(wchar_t),
		(plugin->inum > 1) ? COMPATIBLE_COMPOSITE_IDS_TPL : COMPATIBLE_IDS_TPL,
		plugin->class, plugin->subclass, plugin->protocol, plugin->class, plugin->subclass, plugin->class);
	for (i = 0; i<len / sizeof(wchar_t); i++) {
		if ('Z' == pdodata->compatible_ids[i])
			pdodata->compatible_ids[i] = 0;
	}
	old_pdodata = (PPDO_DEVICE_DATA)InterlockedCompareExchangePointer(&(fo->FsContext), pdodata, 0);
	if (old_pdodata) {
		DBGI(DBG_GENERAL, "you can't plugin again");
		ExFreePool(pdodata->HardwareIDs);
		ExFreePool(pdodata->compatible_ids);
		IoDeleteDevice(pdo);
		return STATUS_INVALID_PARAMETER;
	}
	pdodata->SerialNo = plugin->addr;
	pdodata->fo = fo;
	pdodata->devid = plugin->devid;
	pdodata->speed = plugin->speed;
	bus_init_pdo(pdo, fdodata);

	//
	// Device Relation changes if a new pdo is created. So let
	// the PNP system now about that. This forces it to send bunch of pnp
	// queries and cause the function driver to be loaded.
	//
	IoInvalidateDeviceRelations(fdodata->UnderlyingPDO, BusRelations);

	return status;
}
